---
title: "Regression Analysis of the Ames, Iowa Dataset"
author: "Stuart Miller, Paul Adams, and Chance Robinson"
date: |
  Master of Science in Data Science, Southern Methodist University, USA
lang: en-US
class: man
# figsintext: true
numbersections: true
encoding: UTF-8
bibliography: references.bib
biblio-style: apalike
output:
  bookdown::pdf_document2:
     citation_package: natbib
     keep_tex: true
     toc: false
header-includes:
   - \usepackage{amsmath}
   - \usepackage[utf8]{inputenc}
   - \usepackage[T1]{fontenc}
   - \usepackage{setspace}
   - \usepackage{hyperref}
   - \onehalfspacing
   - \setcitestyle{numbers,square,super}
   - \newcommand\numberthis{\addtocounter{equation}{1}\tag{\theequation}}
editor_options: 
  chunk_output_type: console
---

```{r, lib-read, results='hide', message=FALSE, include=FALSE, echo=FALSE}
### Compuational Setup
# libraries
library(knitr)
library(kableExtra)
library(tidyverse)
library(olsrr)
library(gridExtra)
library(caret)
library(multcomp)
library(Hmisc)

# set a random seed for repodicibility
set.seed(123)

# helper code
source('./helper/visual.R')
source('./helper/data_munging.R')
source('./helper/performance.R')

# load data
train <- read_csv('./data/train.csv')

# data for analysis 2
train2 <- read_csv('./data/train.csv')
test <- read_csv('./data/test.csv')

train <- train %>% 
  filter(Neighborhood %in% c("Edwards", "BrkSide", "NAmes"))
train$Neighborhood <- as.factor(train$Neighborhood)

# create dummy variables with Neighborhood == 'Edwards' as reference
train <- get.dummies(train, "Neighborhood", reference = 'Edwards')

# remove suspect points from training data
train.mod <- train %>% filter(GrLivArea < 4000)

# data for analysis 2
train2 <- train2 %>% filter(GrLivArea < 4000)
```

# Introduction

What is the price of a home in Ames, Iowa?  Our inaugural project in the program curriculum had us competing in an online competition utilizing the linear regression techniques that we’ve learned up to this point.  Our team chose R as the preferred analysis platform as the consensus was that it had more applicable uses in industry.  The objective was to apply various predictive models in order to assess the suitability of our parameter selections in determining the sales price of a home.  The measure of accuracy was logged in terms of the Root Mean Square Error, or RMSE, as well as other comparison models such as cross-validation and the adjusted R-squared.  Our approach was limited in that we not permitted to use more advanced algorithms that we will be exposed to later on, but the exploratory data analysis and data cleaning methods that we’ve learned and made use of here will surely be of use to us in our future personal and academic endeavors.

# Ames, Iowa Data Set

The Ames, Iowa Data Set describes the sale of individual residential properities from 2006-2010 in Ames, Iowa \cite{Cock}. The data was retreved from the dataset hosting site Kaggle, where it is listed under a machine learning competition named \href{https://www.kaggle.com/c/house-prices-advanced-regression-techniques/overview}{\textit{House Prices: Advanced Regression Techniques}} \cite{Kaggle2016}. The data is comprised of 37 numeric features, 43 non-numeric features and an observation index split between a training set and a testing set, which contain 1460 and 1459 observations, respectively. The response variable (`SalePrice`) is only provided for the training set. The output of a model on the test set can be submitted to the Kaggle competition for scoring the performance of the model in terms of RMSE. The first analysis models property sale prices (`SalePrice`) as the response of living room area (`GrLivArea`) of the property and neighborhood (`Neighborhood`) where it is located. In the second analysis, variable selection techniques are used to determine which explanatory varaibles are associated with `SalePrice` to find a predictive model.

# Analysis Question I

## Question of Interest

Century 21 has commissioned an analysis of this data to determine how the sale price of property is related to living room area of the property in the Edwards, Northwest Ames, and Brookside neighborhoods of Ames, IA.

## Modeling

Linear regression will be used to model sale price as a response of the living room area. From the initial exploratory data analysis, it was determined that sale prices should be log-transformed to meet the model assumptions for linearity (see section \ref{appendix:linearity}), thus improving our models fit and reducing standard error. Additionally, two observations were removed as they appeared to be from a different population than the other observations in the dataset (see section \ref{appendix:infleu-points}); therefore, analysis only considers properties with living rooms less than 3500 sq. ft. in area.

We will consider two models: the logarithm of sale price as the response of living room area (1), the reduced model, and the logarithm of sale price as the response of living room area accounting for differences in the three neighborhood of interest (Brookside, Northwest Ames, and Edwards) where Edwards will be used as the reference (2), the full model. An extra sums of square (ESS) test will be used to verify that the addition of `Neighborhood` improves the model.

**Reduced Model**

\begin{equation}
\mu \lbrace log(SalePrice) \rbrace = \beta_0 + \beta_1(LivingRoomArea) (\#eq:reduced)
\end{equation}

**Full Model**

\begin{align}
\mu \lbrace log(SalePrice) \rbrace = \beta_0 + \beta_1(LivingRoomArea) +  \beta_2(Brookside) +\beta_3(NorthwestAmes) + \nonumber\\
\beta_3(Brookside)(LivingRoomArea) + \beta_4(NorthwestAmes)(LivingRoomArea) (\#eq:full)
\end{align}

The ESS test provides convincing evidence that the interaction terms are useful for the model (p-value < 0.0001); thus, we will continue with the full model.

```{r, ESS, echo=FALSE}
# full model formula
model.formula = log(SalePrice) ~ (GrLivArea) + 
     Neighborhood_BrkSide + 
     Neighborhood_NAmes +
     (GrLivArea) * Neighborhood_BrkSide + 
     (GrLivArea) * Neighborhood_NAmes
# reduced model formula
model.reduced.formula = log(SalePrice) ~ (GrLivArea) + 
     Neighborhood_BrkSide + 
     Neighborhood_NAmes

# fit models
model <- lm(formula = model.formula, data = train.mod)
model.reduced <- lm(formula = model.reduced.formula, data = train.mod)
# ESS test on models
anova(model.reduced, model)

```

## Model Assumptions Assessment

The following assessments for model assumptions are made based on Figure \@ref(fig:diag-plots) and Figure \@ref(fig:scatter-plots):

* The residuals of the model appear to be approximately normally distrubited based on the QQ plot of the residuals and histogram of the residuals, suggesting the assumption of normality is met.
* No patterns are evident in the scatter plots of residuals and studentized residuals vs predicted value, suggesting the assumption of constant variance is met.
* While some observations appear to be influential and have high leverage, removing these observations does not have a significant impact on the result of the model fit.
* Based on the scatter plot of the log transform of `SalePrice` vs `GrLivArea`, it appears that a linear model is reasonable (see section \ref{appendix:linearity}).

The sampling procedure is not known. We will assume the independence assumption is met.

```{r, diag-plots, echo=FALSE, fig.width=5, fig.height=5, fig.align='center', fig.cap='Diagnostic Plots', out.width = '45%', fig.pos="htbp", fig.show = 'hold'}
# option 'htbp' is used to lock the position of the image
# option 'hold' is used to arrange images side-by-side

# create plots of residuals
basic.fit.plots(train.mod, model)
# create leverage / outlier plot
ols_plot_resid_lev(model)
```

## Comparing Competing Models

The two models were trained and validated on the training dataset using 10-fold cross validation. The table below summerizes the performance of the models with RMSE, adjusted $R^2$, and PRESS. These results show that the full model is an improvement over the reduced model, which is consistent with the result of the ESS test.

```{r, cross-validation, results='hide', message=FALSE, include=FALSE, echo=FALSE}
## cross validate the full model

# Set up repeated k-fold cross-validation
train.control <- trainControl(method = "cv", number = 10)
# Train the model
model.cv <- train(model.formula, 
                    data = train.mod,
                    method = 'lm',
                    trControl = train.control)
# print model summary
model.cv

# get the CV results
res <- model.cv$results

# get cross-validated PRESS statistic
PCV <- PRESS.cv(model.cv)

## cross validate the reduced model

# Set up repeated k-fold cross-validation
train.control <- trainControl(method = "cv", number = 10)
# Train the model
model.reduced.cv <- train(model.reduced.formula, 
                    data = train.mod,
                    method = 'lm',
                    trControl = train.control)
# print model summary
model.reduced.cv

# get the CV results
res.red <- model.reduced.cv$results

# get cross-validated PRESS statistic
PCV.red <- PRESS.cv(model.reduced.cv)
```

```{r, echo=FALSE}
# print accuracy metrics to md table
kable(data.frame('Model' = c('Full Model', 'Reduced Model'), 
                 'RMSE'=c(res$RMSE, res.red$RMSE),
                 'CV Press'=c(PCV, PCV.red),
                 'Adjused R Squared'=c(res$Rsquared, res.red$Rsquared)),
      "latex", booktabs = T)  %>%
  kable_styling(position = "center")
```

## Parameters

The following table summerizes the parameter estimates for the full model.

```{r, echo=FALSE}
# extract the model estimates from the model summary
sm <- summary(model)
sm.coe <- sm$coefficients
# get the CIs for the coefficients
model.conf <- confint(model)

# print model estimates to md / latex table
kable(data.frame('Parameter' = c('Intercept', 'GrLivArea', 
                                 'Neighborhood_BrkSide', 'Neighborhood_NAmes', 
                                 'GrLivArea:Neighborhood_BrkSide', 'GrLivArea:Neighborhood_NAmes '), 
                 'Estimate'=c(sm.coe[[1]],sm.coe[[2]],sm.coe[[3]],sm.coe[[4]],sm.coe[[5]],sm.coe[[6]]),
                 'CI Lower' = c(model.conf[[1]],model.conf[[2]],model.conf[[3]],
                                model.conf[[4]],model.conf[[5]],model.conf[[6]]),
                 'CI Upper' = c(model.conf[[1,2]],model.conf[[1,2]],model.conf[[3,2]],
                                model.conf[[4,2]],model.conf[[5,2]],model.conf[[6,2]])),
      "latex", booktabs = T)  %>%
  kable_styling(position = "center")
```

Where `Intercept` is $\beta_0$, `GrLivArea` is $\beta_1$, `Neighborhood_BrkSide` is $\beta_2$, `Neighborhood_NAmes` is $\beta_3$, `GrLivArea:Neighborhood_BrkSide` is $\beta_4$, and `GrLivArea:Neighborhood_NAmes` is $\beta_5$

## Model Interpretation

We estimate that for increase in 100 sq. ft., there is associated multiplicative increase in median price of

* 1.055 for the Edwards neighborhood with a 95% confidence interval of [1.044 , 1.066]
* 1.033 for the Northwest Ames neighorhood with a 95% confidence interval of [1.026 , 1.040]
* 1.077 for the Brookside neighorhood with a 95% confidence interval of [1.063 , 1.090]

Since the sampling procedure is not known and this is an observational study, the results only apply to this data.

## Conclusion

```{r, echo=FALSE, results='hide'}
# summary of model to get overall test
summary(lm(model.formula, data = train.mod))
```


In response to the analysis commissioned by Century 21, the log transform of property sale price was modeled as a linear response to the property living room area for residential properties in Ames, IA. It was determined that it was necessary to include interaction terms to allow for the influence of neighborhood on sale price. Based on the model, there is strong evidence of an associated multiplicative increase in median sale price for an increase in living room area (p-vlue < 0.0001, overall F-test).

# Analysis Question II

## Question of Interest

Century 21 has commissioned a second analysis using the same data set, expanded to include as many of the 80 total features, plus the index split, as required to determine the sale price of residential properties across all neighborhoods of Ames, Iowa, beyond only the three - Edwards, Northwest Ames, and Brookside - previously commissioned for analysis.

## Modeling

Through analyzing our variable selection and cross-validation processes - along with our nascant domain knowledge of residential real estate - we ultimately arrived at a multiple linear regression model featuring 11 linear predictor variables and two interaction terms. Specifically, our variable selection process included direct analysis of a correlation plot and a correlation matrix as well as performing forward selection, backward elimination, and stepwise regression. 

Regarding missing data, we imputed NA values for 19 variables using a combination of the data dictionary provided by Century 21 as well as our domain knowledge. After building models with and without transformations applied to variables, we noted no significaznt difference in variable selection from our selection process so elected to use non-transformed predictor variables. We did, however, use the log-transformed `SalePrice` applied in the first analysis.


```{r, replace_na, echo=F, results='hide'}
# Count NAs, impute where needed
na_count <- sapply(train2, function(cnt) sum(length(which(is.na(cnt)))))


train2$GarageYrBlt[is.na(train2$GarageYrBlt)] <- 0
test$GarageYrBlt[is.na(test$GarageYrBlt)] <- 0

train2$LotFrontage[is.na(train2$LotFrontage)] <- mean(train2$LotFrontage, na.rm=TRUE)
test$LotFrontage[is.na(test$LotFrontage)] <- mean(test$LotFrontage, na.rm=TRUE)

train2$MasVnrArea[is.na(train2$MasVnrArea)] <- 0
test$MasVnrArea[is.na(test$MasVnrArea)] <- 0

train2$Alley[is.na(train2$Alley)] <- 'None'
test$Alley[is.na(test$Alley)] <- 'None'

train2$MasVnrType[is.na(train2$MasVnrType)] <- 'None'
test$MasVnrType[is.na(test$MasVnrType)] <- 'None'

train2$BsmtQual[is.na(train2$BsmtQual)] <- 'None'
test$BsmtQual[is.na(test$BsmtQual)] <- 'None'

train2$BsmtCond[is.na(train2$BsmtCond)] <- 'None'
test$BsmtCond[is.na(test$BsmtCond)] <- 'None'

train2$BsmtExposure[is.na(train2$BsmtExposure)] <- 'None'
test$BsmtExposure[is.na(test$BsmtExposure)] <- 'None'

train2$BsmtFinType1[is.na(train2$BsmtFinType1)] <- 'None'
test$BsmtFinType1[is.na(test$BsmtFinType1)] <- 'None'

train2$BsmtFinType2[is.na(train2$BsmtFinType2)] <- 'None'
test$BsmtFinType2[is.na(test$BsmtFinType2)] <- 'None'

train2$FireplaceQu[is.na(train2$FireplaceQu)] <- 'None'
test$FireplaceQu[is.na(test$FireplaceQu)] <- 'None'

train2$GarageType[is.na(train2$GarageType)] <- 'None'
test$GarageType[is.na(test$GarageType)] <- 'None'

train2$GarageFinish[is.na(train2$GarageFinish)] <- 'None'
test$GarageFinish[is.na(test$GarageFinish)] <- 'None'

train2$GarageQual[is.na(train2$GarageQual)] <- 'None'
test$GarageQual[is.na(test$GarageQual)] <- 'None'

train2$GarageCond[is.na(train2$GarageCond)] <- 'None'
test$GarageCond[is.na(test$GarageCond)] <- 'None'

train2$PoolQC[is.na(train2$PoolQC)] <- 'None'
test$PoolQC[is.na(test$PoolQC)] <- 'None'

train2$Fence[is.na(train2$Fence)] <- 'None'
test$Fence[is.na(test$Fence)] <- 'None'

train2$MiscFeature[is.na(train2$MiscFeature)] <- 'None'
test$MiscFeature[is.na(test$MiscFeature)] <- 'None'

train2$Electrical[is.na(train2$Electrical)] <- 'SBrkr'
test$Electrical[is.na(test$Electrical)] <- 'SBrkr'

train2$BldgType[is.na(train2$BldgType)] <- '1Fam'
test$BldgType[is.na(test$BldgType)] <- '1Fam'

train2$BsmtExposure[is.na(train2$BsmtExposure)] <- 'None'
test$BsmtExposure[is.na(test$BsmtExposure)] <- 'None'

train2$Neighborhood <- as.factor(train2$Neighborhood)
test$Neighborhood <- as.factor(test$Neighborhood)

train2$BldgType <- as.factor(train2$BldgType)
test$BldgType <- as.factor(test$BldgType)

train2$HouseStyle <- as.factor(train2$HouseStyle)
test$HouseStyle <- as.factor(test$HouseStyle)

train2$RoofStyle <- as.factor(train2$RoofStyle)
test$RoofStyle <- as.factor(test$RoofStyle)

train2$RoofMatl <- as.factor(train2$RoofMatl)
test$RoofMatl <- as.factor(test$RoofMatl)

train2$Exterior1st <- as.factor(train2$Exterior1st)
test$Exterior1st <- as.factor(test$Exterior1st)

train2$Exterior2nd <- as.factor(train2$Exterior2nd)
test$Exterior2nd <- as.factor(test$Exterior2nd)

train2$ExterQual <- as.factor(train2$ExterQual)
test$ExterQual <- as.factor(test$ExterQual)

train2$ExterCond <- as.factor(train2$ExterCond)
test$ExterCond <- as.factor(test$ExterCond)

train2$Foundation <- as.factor(train2$Foundation)
test$Foundation <- as.factor(test$Foundation)

train2$Heating <- as.factor(train2$Heating)
test$Heating <- as.factor(test$Heating)

train2$HeatingQC <- as.factor(train2$HeatingQC)
test$HeatingQC <- as.factor(test$HeatingQC)

train2$CentralAir <- as.factor(train2$CentralAir)
test$CentralAir <- as.factor(test$CentralAir)

train2$KitchenQual <- as.factor(train2$KitchenQual)
test$KitchenQual <- as.factor(test$KitchenQual)

train2$Functional <- as.factor(train2$Functional)
test$Functional <- as.factor(test$Functional)

train2$PavedDrive <- as.factor(train2$PavedDrive)
test$PavedDrive <- as.factor(test$PavedDrive)

train2$SaleType <- as.factor(train2$SaleType)
test$SaleType <- as.factor(test$SaleType)


train2$Utilities <- as.factor(train2$Utilities)
test$Utilities <- as.factor(test$Utilities)

na_count <- sapply(train2, function(cnt) sum(length(which(is.na(cnt)))))

```

```{r, recode, echo=F, results='hide'}

# 1)  Remove Basement Condition as it is too correlated with Basement Quality
# 2)  Remove Garage Condition as it is too correlated with Garage Quality
# 3)  Remove utilities from the train/test data sets as it doesn't have enough observations in each the 2 levels
train2 = subset(train2, select = -c(Utilities, BsmtCond, GarageCond) )
test = subset(test, select = -c(Utilities, BsmtCond, GarageCond) )



#####################################################################################################################

# The MSSubClass variable appears numeric but should be treated as a factor
# 150 forced to another choice as this wasn't found in the training data set
train2$MSSubClass <- dplyr::recode(train2$MSSubClass, `30` = "30F", `180` = "180F", `45` = "45F", `190` = "190F",
                                  `90` = "190F", `160` = "160F", `50` = "50F", `40` = "40F", `85` = "85F", `70` = "70F",
                                 `80` = "80F", `20` = "20F", `75` = "75F", `120` = "120F", `60` = "60F", `150` = "75F")

test$MSSubClass <- dplyr::recode(test$MSSubClass, `30` = "30F", `180` = "180F", `45` = "45F", `190` = "190F",
                                  `90` = "190F", `160` = "160F", `50` = "50F", `40` = "40F", `85` = "85F", `70` = "70F",
                                 `80` = "80F", `20` = "20F", `75` = "75F", `120` = "120F", `60` = "60F", `150` = "75F")


train2$MSSubClass <- as.factor(train2$MSSubClass)
test$MSSubClass <- as.factor(test$MSSubClass)


#####################################################################################################################
train2$GarageQual <- dplyr::recode(train2$GarageQual, 'None' = 0, 'Po' = 1, 'Fa' = 2, 'TA' = 3, 'Gd' = 4, 'Ex' = 5)
test$GarageQual <- dplyr::recode(test$GarageQual, 'None' = 0, 'Po' = 1, 'Fa' = 2, 'TA' = 3, 'Gd' = 4, 'Ex' = 5)

train2$GarageFinish <- dplyr::recode(train2$GarageFinish, 'None' = 0, 'Unf' = 1, 'RFn' = 2, 'Fin' = 3)
test$GarageFinish <- dplyr::recode(test$GarageFinish, 'None' = 0, 'Unf' = 1, 'RFn' = 2, 'Fin' = 3)

train2$GarageType <- dplyr::recode(train2$GarageType, 'None' = 0, 'CarPort' = 1, '2Types' = 2, 
                                  'Basment' = 3, 'Detchd' = 4, 'Attchd' = 5, 'BuiltIn' = 6)
test$GarageType <- dplyr::recode(test$GarageType, 'None' = 0, 'CarPort' = 1, '2Types' = 2, 
                                 'Basment' = 3, 'Detchd' = 4, 'Attchd' = 5, 'BuiltIn' = 6)

# train2$GarageCond <- dplyr::recode(train2$GarageCond, 'None' = 0, 'Po' = 1, 'Fa' = 2, 'TA' = 3, 'Gd' = 4, 'Ex' = 5)
# test$GarageCond <- dplyr::recode(test$GarageCond, 'None' = 0, 'Po' = 1, 'Fa' = 2, 'TA' = 3, 'Gd' = 4, 'Ex' = 5)

#####################################################################################################################

train2$BsmtQual <- dplyr::recode(train2$BsmtQual, 'None' = 0, 'Po' = 1, 'Fa' = 2, 'TA' = 3, 'Gd' = 4, 'Ex' = 5)
test$BsmtQual <- dplyr::recode(test$BsmtQual, 'None' = 0, 'Po' = 1, 'Fa' = 2, 'TA' = 3, 'Gd' = 4, 'Ex' = 5)

# train2$BsmtCond <- dplyr::recode(train2$BsmtCond, 'None' = 0, 'Po' = 1, 'Fa' = 2, 'TA' = 3, 'Gd' = 4, 'Ex' = 5)
# test$BsmtCond <- dplyr::recode(test$BsmtCond, 'None' = 0, 'Po' = 1, 'Fa' = 2, 'TA' = 3, 'Gd' = 4, 'Ex' = 5)

train2$BsmtFinType1 <- dplyr::recode(train2$BsmtFinType1, 'None' = 0, 'Unf' = 1, 'LwQ' = 2, 'Rec' = 3, 
                                    'BLQ' = 4, 'ALQ' = 5, 'GLQ' = 6)
test$BsmtFinType1 <- dplyr::recode(test$BsmtFinType1, 'None' = 0, 'Unf' = 1, 'LwQ' = 2, 'Rec' = 3, 
                                   'BLQ' = 4, 'ALQ' = 5, 'GLQ' = 6)


train2$BsmtFinType2 <- dplyr::recode(train2$BsmtFinType2, 'None' = 0, 'Unf' = 1, 'LwQ' = 2, 'Rec' = 3, 
                                    'BLQ' = 4, 'ALQ' = 5, 'GLQ' = 6)
test$BsmtFinType2 <- dplyr::recode(test$BsmtFinType2, 'None' = 0, 'Unf' = 1, 'LwQ' = 2, 'Rec' = 3, 
                                   'BLQ' = 4, 'ALQ' = 5, 'GLQ' = 6)


train2$BsmtExposure <- dplyr::recode(train2$BsmtExposure, 'None' = 0, 'No' = 1, 'Mn' = 2, 'Av' = 3, 'Gd' = 4)
test$BsmtExposure <- dplyr::recode(test$BsmtExposure, 'None' = 0, 'No' = 1, 'Mn' = 2, 'Av' = 3, 'Gd' = 4)

#####################################################################################################################

train2$LandSlope <- dplyr::recode(train2$LandSlope, 'Sev' = 0, 'Mod' = 1, 'Gtl' = 2)
test$LandSlope <- dplyr::recode(test$LandSlope, 'Sev' = 0, 'Mod' = 1, 'Gtl' = 2)


train2$MSZoning <- dplyr::recode(train2$MSZoning, 'C (all)' = 0, 'RM' = 1, 'RH' = 2, 'RL' = 3, 'FV' = 4)
test$MSZoning <- dplyr::recode(test$MSZoning, 'C (all)' = 0, 'RM' = 1, 'RH' = 2, 'RL' = 3, 'FV' = 4)


train2$PoolQC <- dplyr::recode(train2$PoolQC, 'None' = 0, 'Po' = 1, 'Fa' = 2, 'TA' = 3, 'Gd' = 4, 'Ex' = 5)
test$PoolQC <- dplyr::recode(test$PoolQC, 'None' = 0, 'Po' = 1, 'Fa' = 2, 'TA' = 3, 'Gd' = 4, 'Ex' = 5)


train2$FireplaceQu <- dplyr::recode(train2$FireplaceQu, 'None' = 0, 'Po' = 1, 'Fa' = 2, 'TA' = 3, 'Gd' = 4, 'Ex' = 5)
test$FireplaceQu <- dplyr::recode(test$FireplaceQu, 'None' = 0, 'Po' = 1, 'Fa' = 2, 'TA' = 3, 'Gd' = 4, 'Ex' = 5)

#####################################################################################################################

```


```{r, convert_to_factor, echo=F, results='hide'}

train$Street <- ordered(train$Street, levels = c("Grvl", "Pave"))
test$Street <- ordered(test$Street, levels = c("Grvl", "Pave"))

train$LotShape <- ordered(train$LotShape, levels = c("Reg", "IR1", "IR2", "IR3"))
test$LotShape <- ordered(test$LotShape, levels = c("Reg", "IR1", "IR2", "IR3"))

train$LandContour <- ordered(train$LandContour, levels = c("Bnk", "Lvl", "Low", "HLS"))
test$LandContour <- ordered(test$LandContour, levels = c("Bnk", "Lvl", "Low", "HLS"))

train$LotConfig <- ordered(train$LotConfig, levels = c("Inside", "Corner", "CulDSac", "FR2", "FR3"))
test$LotConfig <- ordered(test$LotConfig, levels = c("Inside", "Corner", "CulDSac", "FR2", "FR3"))

train$Condition1 <- ordered(train$Condition1, levels = c("Artery", "Feedr", "RRAe", "Norm", "RRAn", "RRNe", "RRNn", "PosA", "PosN"))
test$Condition1 <- ordered(test$Condition1, levels = c("Artery", "Feedr", "RRAe", "Norm", "RRAn", "RRNe", "RRNn", "PosA", "PosN"))

train$Condition2 <- ordered(train$Condition2, levels = c("Artery", "RRNn","RRAn","Feedr", "Norm", "RRAe", "PosN", "PosA"))
test$Condition2 <- ordered(test$Condition2, levels = c("Artery", "RRNn","RRAn","Feedr", "Norm", "RRAe", "PosN", "PosA"))

train$Alley <- ordered(train$Alley, levels = c("None", "Grvl", "Pave"))
test$Alley <- ordered(test$Alley, levels = c("None", "Grvl", "Pave"))

train$MasVnrType <- ordered(train$MasVnrType, levels = c("None", "CBlock", "BrkFace", "BrkCmn", "Stone"))
test$MasVnrType <- ordered(test$MasVnrType, levels = c("None", "CBlock", "BrkFace", "BrkCmn", "Stone"))

train$Fence <- ordered(train$Fence, levels = c("None", "MnWw", "GdWo", "MnPrv", "GdPrv"))
test$Fence <- ordered(test$Fence, levels = c("None", "MnWw", "GdWo", "MnPrv", "GdPrv"))

train$Electrical <- ordered(train$Electrical, levels = c("Mix", "FuseP", "FuseF", "FuseA", "SBrkr"))
test$Electrical <- ordered(test$Electrical, levels = c("Mix", "FuseP", "FuseF", "FuseA", "SBrkr"))

train$MiscFeature <- ordered(train$MiscFeature, levels = c("None", "Othr", "Shed", "Gar2", "TenC"))
test$MiscFeature <- ordered(test$MiscFeature, levels = c("None", "Othr", "Shed", "Gar2", "TenC"))

train$SaleCondition <- factor(train$SaleCondition, levels = c("Abnorml", "AdjLand", "Alloca", "Partial", "Family", "Normal"))
test$SaleCondition <- factor(test$SaleCondition, levels = c("Abnorml", "AdjLand", "Alloca", "Partial", "Family", "Normal"))

```


**Forward Selection**

Forward selection is a variable selection methodology that begins with a constant mean and adds explanatory variables one-by-one until no further additonal predictor variables significantly improve the model's fit. This employess the "F-to-enter" method from the extra-sum-of-squares F-statistic. This was the first method we employed. For this process, we provided the test a starting model with no predictor variables and a model from which terms can be selected, which included all predictor variables available. The process worked forward with selecting one parameter. The suggested model shown in section \ref{appendix:forSelection}.


```{r, echo=F, results='hide'}
# Initial Model - Forward Selection
model2.forward.Start <- lm(log(SalePrice)~1,data = train2)

# All Variables Model - Forward Selection
model2.Allvar <- lm(log(SalePrice) ~ OverallQual + GrLivArea + Neighborhood + 
                      BsmtFinSF1 + MSSubClass + OverallCond + YearBuilt + GarageCars + 
                      TotalBsmtSF + SaleCondition + LotArea + MSZoning + Functional + 
                      CentralAir + KitchenQual + Condition1 + FireplaceQu + BsmtExposure + 
                      BsmtFullBath + ScreenPorch + Exterior1st + YearRemodAdd + 
                      GarageQual + WoodDeckSF + OpenPorchSF + Street + LotConfig + 
                      LotFrontage + Foundation + Heating + KitchenAbvGr + EnclosedPorch + 
                      HalfBath + FullBath + MasVnrType + BsmtFinSF2 + HeatingQC + 
                      GarageArea + SaleType + ExterCond + PoolArea + BsmtFinType1 + 
                      GarageYrBlt + Electrical + `3SsnPorch` + LowQualFinSF, data = train2
                    )

#### Forward Selection, first pass
model2.Forward <- stepAIC(model2.forward.Start, direction = "forward", trace = F, scope = formula(model2.Allvar))

summary(model2.Forward)
model2.Forward$anova

##### If needed for display, this is the final model, final pass with Forward Selection#####

#model2.final.Forward <- stepAIC(fitFull.all4.Final, direction = "forward", trace = F, scope = formula(model2.Allvar))
# summary(model2.final.Forward)
# model2.final.Forward$anova

############################## First-pass suggested output from Forward Selection:
final.Forward.Model <- lm(log(SalePrice) ~ OverallQual + GrLivArea + Neighborhood + 
                            BsmtFinSF1 + MSSubClass + OverallCond + YearBuilt + GarageCars + 
                            TotalBsmtSF + SaleCondition + LotArea + MSZoning + Functional + 
                            CentralAir + KitchenQual + Condition1 + FireplaceQu + BsmtExposure + 
                            BsmtFullBath + ScreenPorch + Exterior1st + YearRemodAdd + 
                            GarageQual + WoodDeckSF + OpenPorchSF + Street + LotConfig + 
                            LotFrontage + Foundation + Heating + KitchenAbvGr + EnclosedPorch + 
                            HalfBath + FullBath + MasVnrType + BsmtFinSF2 + HeatingQC + 
                            GarageArea + SaleType + ExterCond + PoolArea + BsmtFinType1 + 
                            GarageYrBlt + Electrical + `3SsnPorch` + LowQualFinSF, data = train2
                          )
```


**Backward Elimination**

Backward elimination is a variable selection methodology that begins with all possible predictor variables and works backward, eliminating variables using all possible combinations until only the best for the fit are provided. This employess the "F-to-remove" method from the extra-sum-of-squares F-statistic. For this process, we provided the test a model with all available predictor variables from which insignificant variables were eliminated. The suggested model shown in section \ref{appendix:backSelection}.

```{r, echo=F, results='hide'}
# Backward Elimination
model2.Backward <- stepAIC(model2.Allvar, direction = "backward", trace = F, scope = formula(model2.forward.Start))

summary(model2.Backward)
model2.Backward$anova

############################## First-pass suggested output from Backward Elimination:
final.Backward.Model <- lm(log(SalePrice) ~ MSSubClass + MSZoning + LotFrontage +
                              LotArea + Street + LotConfig + LandSlope + Neighborhood +
                              Condition1 + OverallQual + OverallCond + YearBuilt + YearRemodAdd +
                              RoofMatl + Exterior1st + MasVnrType + ExterCond + Foundation +
                              BsmtExposure + BsmtFinType1 + BsmtFinSF1 + BsmtFinSF2 + BsmtUnfSF +
                              Heating + HeatingQC + CentralAir + Electrical + `1stFlrSF` +
                              `2ndFlrSF` + LowQualFinSF + BsmtFullBath + FullBath + HalfBath +
                              KitchenAbvGr + KitchenQual + Functional + FireplaceQu + GarageYrBlt +
                              GarageCars + GarageArea + GarageQual + WoodDeckSF + OpenPorchSF +
                              EnclosedPorch + ScreenPorch + PoolArea + SaleType + SaleCondition, data = train2
                           )

##### If needed for display, this is the final model, final validation with Backward Elimination
#model2.final.Backward <- stepAIC(fitFull.all4.Final, direction = "backward", trace = F)
# summary(model2.final.Backward)
# model2.final.Backward$anova
```

**Stepwise Regression**

Stepwise regression is a variable selection methodology that performs one step of forward selection for each step of backward elimination. The steps are repeated, concurrently, until no further predictor variables can be added or removed. This is the third model approach we used. The suggested model shown in section \ref{appendix:stepWSelection}.

```{r, echo=F, results='hide'}
# Stepwise Selection
model2.Stepwise <- stepAIC(model2.Allvar, direction = "both", trace = F)

summary(model2.Stepwise)
model2.Stepwise$anova

############################## First-pass suggested output from Stepwise Regression:
final.Stepwise.Model <- lm(log(SalePrice) ~ OverallQual + GrLivArea + Neighborhood + 
                              BsmtFinSF1 + MSSubClass + OverallCond + YearBuilt + GarageCars + 
                              TotalBsmtSF + SaleCondition + LotArea + MSZoning + Functional + 
                              CentralAir + KitchenQual + Condition1 + FireplaceQu + BsmtExposure + 
                              BsmtFullBath + ScreenPorch + Exterior1st + YearRemodAdd + 
                              GarageQual + WoodDeckSF + OpenPorchSF + Street + LotConfig + 
                              LotFrontage + Foundation + Heating + KitchenAbvGr + EnclosedPorch + 
                              HalfBath + FullBath + MasVnrType + BsmtFinSF2 + HeatingQC + 
                              GarageArea + SaleType + ExterCond + PoolArea + BsmtFinType1 + 
                              GarageYrBlt + Electrical + `3SsnPorch` + LowQualFinSF, data = train2
                           )

# If needed for display, this is the final model, final validation with Stepwise Regression
#stepwise.final.model4 <- stepAIC(fitFull.all4.Final, direction = "both", trace = F)
#summary(stepwise.final.model4)
#stepwise.final.model4$anova
```

**Custom Variable Selection** 

To develop the custom model, we employed a combination of a correlation matrix for quantitative data, analysis of the summarization of the suggested model from stepwise selection, and through direct analysis of the pairs plots. As previously mentioned, our final model included 11 linear terms and two interaction terms. We removed all variables suggested to be removed by the stepwise regression and backward elimination tests, then reprocessed the updated models until forward selection, backward elimination, and stepwise regression were in agreeance with respect to the linear terms. Once this trial-and-error process was completed, we added interaction terms based on domain knowledge and re-applied the forward selection, backward elimination, and stepwise regression methods until only significant terms - both linear and interactive - remained. We then used graphical analysis to visually confirm interaction between the interactive terms remaining. The custom model shown in section \ref{appendix:customSelection}.

```{r, echo=F, results='hide'}

#train2.numeric <- dplyr::select_if(train2, is.numeric) %>% data.frame()

#flattenCorrMatrix <- function(cormatrix, pmatrix) {
#  ut <- upper.tri(cormatrix)
# data.frame(
#    row = rownames(cormatrix)[row(cormatrix)[ut]],
#    column = rownames(cormatrix)[col(cormatrix)[ut]],
#    cor  =(cormatrix)[ut],
#    p = pmat[ut]
#    )
#}

#See what variables are correlated with eachother, p-values
#correlation.matrix <- rcorr(as.matrix(train2.numeric))
#corDF <- data.frame(flattenCorrMatrix(correlation.matrix$r, correlation.matrix$P))

#Order the correlation matrix to show the highest correlated
#data.frame(corDF[order(-corDF$cor),])
#quantDataModel <- corDF[which(corDF$cor >= 0.5),]

fitFull.all4.Final <- lm(log(SalePrice) ~ MSSubClass + MSZoning + LotFrontage + 
                            LotArea + Street + Neighborhood + 
                            Condition1 + OverallQual + OverallCond + YearBuilt + YearRemodAdd + 
                            ExterCond + Foundation + 
                            BsmtExposure + BsmtFinType1 + BsmtFinSF1 + BsmtFinSF2 + BsmtUnfSF + 
                            HeatingQC + CentralAir + Electrical + `1stFlrSF` + 
                            `2ndFlrSF` + LowQualFinSF + BsmtFullBath + FullBath + HalfBath + 
                            KitchenAbvGr + KitchenQual + Functional + FireplaceQu + GarageYrBlt + 
                            GarageCars + GarageArea + GarageQual + WoodDeckSF + OpenPorchSF + 
                            EnclosedPorch + ScreenPorch + SaleType + SaleCondition, data = train2)

######################################################################
###We need the graphs for interactive terms to display interaction####
######################################################################
```

## Model Assumption Assessment

The assumption assessment plots were similar for all four models. The assumption assessment plots and discussion for the custom model are provided here with Figure \@ref(fig:custom-assumptions). The assumption assessment plots for the other three models are provided for reference in section \ref{appendix:assessmentPlots}.

Based on the residuals vs. fitted plot, there seems to be strong linearity in the custom model, along with constant variance. The standardized residuals do not appear to exhibit a discernible pattern, indicating constant variance along the regression, or homoscedasticity. While there some outliers, this is not appear to be an egregious violation. 

Based on the QQ plot, there is a small level of deviation on the ends of the distribution of the errors, but for the most part, the errors adhere to normality. The sample size should be sufficient to protect against this non-normality.

Based on the standardized residuals vs. leverage plot, only a few values have high leverage and are outlying. However, these violations do not appear to be egregious.


```{r, custom-assumptions, echo=F, warning=F, fig.width=5, fig.height=5, fig.align='center', fig.cap='Custom Assumption Assessment Plots', out.width = '45%', fig.pos="htbp", fig.show = 'hold'}
#par(mfrow=c(2,2))
#plot(fitFull.all4.Final, main = "Custom Model")

# create plots of residuals
basic.fit.plots(train2, fitFull.all4.Final)
# create leverage / outlier plot
ols_plot_resid_lev(fitFull.all4.Final)
```

\newpage

## Comparing Competing Models

While the models from forward, backward, and stepwise selection produce higher adjusted $R^2$ values on the training data, the yield much higher errors when applied to the Kaggle test set. These selection methods appear to be overfitting to the training data, thus fail to generalize to the Kaggle test set. Undisputedly, the custom model outperformed the model built strictly on the output of the forward selection, backward elimination, and stepwise regression variable selection procedures when applied to a new dataset.

```{r, echo=F, results='hide', warning=F}
#The final adjusted $R^2$ of our custom model is 0.9303:
R2.custom <- summary(fitFull.all4.Final)$adj.r.squared ##Custom Model
```

```{r, echo=F, results='hide', warning=F}
#The final adjusted $R^2$ of our Forward Selection model is 0.9327:
R2.forward <- summary(model2.Forward)$adj.r.squared
```


```{r, echo=F, results='hide', warning=F}
#The final adjusted $R^2$ of our Backward Elimination model is 0.9329:
R2.backward <- summary(model2.Backward)$adj.r.squared
```


```{r, echo=F, results='hide', warning=F}
#The final adjusted $R^2$ of our Stepwise Regression model is 0.9327:
R2.step <- summary(model2.Stepwise)$adj.r.squared
```

```{r, echo=F, results='hide', warning=F}
#Our cross-validated PRESS statistic output for our custom model is below.

# Set up repeated k-fold cross-validation
train.control2 <- trainControl(method = "cv", number = 10)
# Train the model
model.cv2 <- train(log(SalePrice) ~ MSSubClass + MSZoning + LotFrontage + 
                      LotArea + Street + Neighborhood + 
                      Condition1 + OverallQual + OverallCond + YearBuilt + YearRemodAdd + 
                      ExterCond + Foundation + 
                      BsmtExposure + BsmtFinType1 + BsmtFinSF1 + BsmtFinSF2 + BsmtUnfSF + 
                      HeatingQC + CentralAir + Electrical + `1stFlrSF` + 
                      `2ndFlrSF` + LowQualFinSF + BsmtFullBath + FullBath + HalfBath + 
                      KitchenAbvGr + KitchenQual + Functional + FireplaceQu + GarageYrBlt + 
                      GarageCars + GarageArea + GarageQual + WoodDeckSF + OpenPorchSF + 
                      EnclosedPorch + ScreenPorch + SaleType + SaleCondition,
                   data = train2,
                   method = 'lm',
                   trControl = train.control2)

# print model summary
model.cv2

# get the CV results
res <- model.cv2$results

# get cross-validated PRESS statistic
PCV.custom <- PRESS.cv(model.cv2)
```

```{r, echo=F, results='hide', warning=F}
#Our cross-validated PRESS statistic output for our Forward Selection model is below.

# Set up repeated k-fold cross-validation
train.control2 <- trainControl(method = "cv", number = 10)
# Train the model
model.cv2 <- train(log(SalePrice) ~ OverallQual + GrLivArea + Neighborhood + 
                      BsmtFinSF1 + MSSubClass + OverallCond + YearBuilt + GarageCars + 
                      TotalBsmtSF + SaleCondition + LotArea + MSZoning + Functional + 
                      CentralAir + KitchenQual + Condition1 + FireplaceQu + BsmtExposure + 
                      BsmtFullBath + ScreenPorch + Exterior1st + YearRemodAdd + 
                      GarageQual + WoodDeckSF + OpenPorchSF + Street + LotConfig + 
                      LotFrontage + Foundation + Heating + KitchenAbvGr + EnclosedPorch + 
                      HalfBath + FullBath + MasVnrType + BsmtFinSF2 + HeatingQC + 
                      GarageArea + SaleType + ExterCond + PoolArea + BsmtFinType1 + 
                      GarageYrBlt + Electrical + `3SsnPorch` + LowQualFinSF,
                   data = train2,
                   method = 'lm',
                   trControl = train.control2)

# print model summary
model.cv2

# get the CV results
res <- model.cv2$results

# get cross-validated PRESS statistic
PCV.forward <- PRESS.cv(model.cv2)
```

```{r, echo=F, results='hide', warning=F}
#Our cross-validated PRESS statistic output for our Backward Elimination model is below.

# Set up repeated k-fold cross-validation
train.control2 <- trainControl(method = "cv", number = 10)
# Train the model
model.cv2 <- train(log(SalePrice) ~ MSSubClass + MSZoning + LotFrontage +
                      LotArea + Street + LotConfig + LandSlope + Neighborhood +
                      Condition1 + OverallQual + OverallCond + YearBuilt + YearRemodAdd +
                      RoofMatl + Exterior1st + MasVnrType + ExterCond + Foundation +
                      BsmtExposure + BsmtFinType1 + BsmtFinSF1 + BsmtFinSF2 + BsmtUnfSF +
                      Heating + HeatingQC + CentralAir + Electrical + `1stFlrSF` +
                      `2ndFlrSF` + LowQualFinSF + BsmtFullBath + FullBath + HalfBath +
                      KitchenAbvGr + KitchenQual + Functional + FireplaceQu + GarageYrBlt +
                      GarageCars + GarageArea + GarageQual + WoodDeckSF + OpenPorchSF +
                      EnclosedPorch + ScreenPorch + PoolArea + SaleType + SaleCondition,
                   data = train2,
                   method = 'lm',
                   trControl = train.control2)

# print model summary
model.cv2

# get the CV results
res <- model.cv2$results

# get cross-validated PRESS statistic
PCV.backward <- PRESS.cv(model.cv2)
```

```{r, echo=F, results='hide', warning=F}

#Our cross-validated PRESS statistic output for our Stepwise Regression model is below.
# Set up repeated k-fold cross-validation
train.control2 <- trainControl(method = "cv", number = 10)
# Train the model
model.cv2 <- train(log(SalePrice) ~ OverallQual + GrLivArea + Neighborhood + 
                      BsmtFinSF1 + MSSubClass + OverallCond + YearBuilt + GarageCars + 
                      TotalBsmtSF + SaleCondition + LotArea + MSZoning + Functional + 
                      CentralAir + KitchenQual + Condition1 + FireplaceQu + BsmtExposure + 
                      BsmtFullBath + ScreenPorch + Exterior1st + YearRemodAdd + 
                      GarageQual + WoodDeckSF + OpenPorchSF + Street + LotConfig + 
                      LotFrontage + Foundation + Heating + KitchenAbvGr + EnclosedPorch + 
                      HalfBath + FullBath + MasVnrType + BsmtFinSF2 + HeatingQC + 
                      GarageArea + SaleType + ExterCond + PoolArea + BsmtFinType1 + 
                      GarageYrBlt + Electrical + `3SsnPorch` + LowQualFinSF,
                   data = train2,
                   method = 'lm',
                   trControl = train.control2)

# print model summary
model.cv2

# get the CV results
res <- model.cv2$results

# get cross-validated PRESS statistic
PCV.stepwise <- PRESS.cv(model.cv2)
```

```{r,echo=F, results='hide', warning=F}
#Our custom model achieved a Kaggle score of 0.13290. This was our best score.

## To test in Kaggle, submit the produced "submit" file
test$predicted.log.price <- predict.lm(fitFull.all4.Final, test)
test$predicted.log.price[is.na(test$predicted.log.price)] <- mean(test$predicted.log.price, na.rm = T)

submit <- test %>% mutate(SalePrice = exp(predicted.log.price)) %>% subset(select=c(Id, SalePrice))

write.csv(submit, file = "./kaggle_submission.csv", row.names = F)
```

```{r,echo=F, results='hide', warning=F}
#Our Forward Selection model achieved a Kaggle score of 0.13476

## To test in Kaggle, submit the produced "submit" file
test$predicted.log.price <- predict.lm(final.Forward.Model, test)
test$predicted.log.price[is.na(test$predicted.log.price)] <- mean(test$predicted.log.price, na.rm = T)

submit <- test %>% mutate(SalePrice = exp(predicted.log.price)) %>% subset(select=c(Id, SalePrice))

# write.csv(submit, file = "./kaggle_submission.csv", row.names = F)
```

```{r,echo=F, results='hide', warning=F}
#Our Backward Selection model achieved a Kaggle score of 0.13475

## To test in Kaggle, submit the produced "submit" file
test$predicted.log.price <- predict.lm(final.Backward.Model, test)
test$predicted.log.price[is.na(test$predicted.log.price)] <- mean(test$predicted.log.price, na.rm = T)

submit <- test %>% mutate(SalePrice = exp(predicted.log.price)) %>% subset(select=c(Id, SalePrice))

# write.csv(submit, file = "./kaggle_submission.csv", row.names = F)
```

```{r,echo=F, results='hide', warning=F}
#Our Stepwise Regression model also achieved a Kaggle score of 0.13476

## To test in Kaggle, submit the produced "submit" file
test$predicted.log.price <- predict.lm(final.Stepwise.Model, test)
test$predicted.log.price[is.na(test$predicted.log.price)] <- mean(test$predicted.log.price, na.rm = T)

submit <- test %>% mutate(SalePrice = exp(predicted.log.price)) %>% subset(select=c(Id, SalePrice))

# write.csv(submit, file = "./kaggle_submission.csv", row.names = F)
```


```{r, echo=FALSE}
# print accuracy metrics to md table

kable(data.frame('Model' = c('Custom', 'Forward Selection', 'Backward Selection', 'Stepwise Regression'), 
                 'Kaggle Score'=c(0.13290,0.13476,0.13475,0.13476),
                 'CV Press'=c(PCV.custom, PCV.forward, PCV.backward, PCV.stepwise),
                 'Adjused R Squared'=c(R2.custom, R2.forward, R2.backward, R2.step)),
      "latex", booktabs = T)  %>%
  kable_styling(position = "center")
```

## Conclusion

In an effort to produce very predictive model with linear regression, all explanatory variables were considered with three types of varaible selection techniques: forward selection, backward selection, stepwise selection. A custom model was initially produced by eleminating variables suggested for elimination by the automatic selection processes, exploring the data with pairwise scatter plots, and adding interaction terms based on graphical analysis and domain knowledge. Automated selection was reapplied to suggest terms from the initial custom model. The final models suggested by automated techniques produced high $R^2$ values, but performed poorly on the Kaggle test set. This suggests the automated techniques were overfitting to the training data. The final custom model, produced a high $R^2$ value and perfromed well on the Kaggle test set (see section \ref{appendix:kaggle}). This suggests that the custom model is not overfitting to the traing data and generalizes well to an unseen dataset.

\newpage

# Appendix

## Checking for Linearity in `SalePrice` vs `GrLivArea`

\label{appendix:linearity}

The scatter plot in Figure \@ref(fig:scatter-plot) shows relationship of `SalePrice` vs `GrLivArea` for all three neighborhoods of interest to Century 21. Based on this plot, it does not appear that this relationship meets the assumptions of linear regression, specifically the constant varaince assumption. The response will be transformed to attempt to handle the changing variance.

```{r, scatter-plot, echo=FALSE, fig.width=5, fig.height=5, fig.align='center', fig.cap='Scatter Plot of Sale Price vs Living Room Area', out.width = '45%', fig.pos="htbp"}

# scatter plot of observations from all three neighborhoods
train %>% 
  ggplot(aes(x = (GrLivArea), y = (SalePrice))) +
  geom_point(alpha = 0.3) +
  labs(title = 'Sale Price vs Living Room Area', 
       y = 'Sale Price', x = 'Living Room Area (sq. ft.)')
```

The images below show the scatter plots of log sale price vs living room area (Figure \@ref(fig:scatter-plots)). In the image on the right, the scatter plot is shown for each neighborhood. In the image on the left the observations for all three neighborhoods are included. In all cases, a linear model appears to be reasonable to model this data.

```{r, scatter-plots, echo=FALSE, fig.width=5, fig.height=5, fig.align='center', fig.cap='Scatter Plots of Log of Sale Price vs Living Room Area', out.width = '45%', fig.pos="htbp", fig.show='hold'}

# plots of log of sale price ~ living room area

# create scatter plot for northwest ames
regplot.names <- train %>% filter(Neighborhood == 'NAmes') %>%
  ggplot(aes(x = (GrLivArea), y = log(SalePrice))) +
  geom_point(alpha = 0.3) +
  ylim(10, 13) +
  xlim(0, 3500) +
  labs(subtitle = 'Northwest Ames', 
       y = 'Log of Sale Price', x = 'Living Room Area (sq. ft.)')

# create scatter plot for edwards
regplot.ed <- train %>%
  filter(GrLivArea < 4000) %>%
  filter(Neighborhood == 'Edwards') %>%
  ggplot(aes(x = (GrLivArea), y = log(SalePrice))) +
  geom_point(alpha = 0.3) +
  ylim(10, 13) +
  xlim(0, 3500) +
  labs(subtitle = 'Edwards', 
       y = 'Log of Sale Price', x = 'Living Room Area (sq. ft.)')

# create regression plot for brookside
regplot.brk <- train %>% filter(Neighborhood == 'BrkSide') %>%
  ggplot(aes(x = (GrLivArea), y = log(SalePrice))) +
  geom_point(alpha = 0.3) +
  ylim(10, 13) +
  xlim(0, 3500) +
  labs(subtitle = 'Brook Side', 
       y = 'Log of Sale Price', x = 'Living Room Area (sq. ft.)')

# add the scatter plots for the neighborhood into a single plot
grid.arrange(regplot.names,regplot.ed,regplot.brk, nrow = 2,
             top = 'Regression Plots for Neighborhoods')

# scatter plot of observations from all three neighborhoods
train %>% 
  filter(GrLivArea < 4000) %>%
  ggplot(aes(x = (GrLivArea), y = log(SalePrice))) +
  geom_point(alpha = 0.3) +
  labs(title = 'Log of Sale Price vs Living Room Area', 
       y = 'Log of Sale Price', x = 'Living Room Area (sq. ft.)')
```


## Analysis of Influential points

\label{appendix:infleu-points}

The two outlying observations with living room areas greater than 4000 sq. ft. appear to be from a different distribution than the main dataset. Since these are partial sales, it is possible that the sale prices do not reflect market value. For this reason, we will limit the analysis to properities with less than 3500 sq. ft.  \@ref(fig:infleu-points)

```{r, infleu-points, echo=FALSE, fig.width=5, fig.height=5, fig.align='center', fig.cap='Influential Points', out.width = '50%', fig.pos="htbp"}

# scatter plot of observations from all three neighborhoods with labeling by `SaleCondition`
train %>% ggplot(aes(x = (GrLivArea), y = log(SalePrice))) +
  geom_point(alpha = 0.3) +
  labs(title = 'Log of Sale Price vs Living Room Area', 
       y = 'Log of Sale Price', x = 'Living Room Area (sq. ft.)') +
  geom_text(aes(label = ifelse((log(GrLivArea) > 7.75 & log(SalePrice) > 11) |
                                 (log(SalePrice) > 12.45),
                               SaleCondition, '')), hjust=0, vjust=0)
```

\newpage

## Models Suggested by Automated Selection

### Forward Selection

\label{appendix:forSelection}

The model suggested by forward selection.

```r
log(SalePrice) ~ 
              OverallQual + GrLivArea + Neighborhood + BsmtFinSF1 +
              OverallCond + YearBuilt + TotalBsmtSF + GarageCars + MSZoning +
              SaleCondition + BldgType + Functional + LotArea + KitchenQual +
              BsmtExposure + CentralAir + Condition1 + ScreenPorch + BsmtFullBath +
              Heating + Fireplaces + YearRemodAdd + Exterior1st + GarageQual +
              WoodDeckSF + SaleType + OpenPorchSF + HeatingQC + LotConfig +
              EnclosedPorch + ExterCond + PoolQC + Foundation + LandSlope +
              RoofMatl + GarageArea + MasVnrType + HalfBath + PoolArea +
              `3SsnPorch` + Street + KitchenAbvGr + GarageCond + FullBath +
              BsmtQual + BsmtFinSF2
```

### Backward Selection

\label{appendix:backSelection}

```r
log(SalePrice) ~ 
           MSZoning + LotArea + Street + LotConfig + LandSlope +
           Neighborhood + Condition1 + Condition2 + BldgType + OverallQual +
           OverallCond + YearBuilt + YearRemodAdd + RoofStyle + RoofMatl +
           Exterior1st + MasVnrType + ExterCond + Foundation + BsmtQual +
           BsmtCond + BsmtExposure + BsmtFinSF1 + BsmtFinSF2 + BsmtUnfSF +
           Heating + HeatingQC + CentralAir + `1stFlrSF` + `2ndFlrSF` +
           LowQualFinSF + BsmtFullBath + FullBath + HalfBath + KitchenAbvGr +
           KitchenQual + Functional + Fireplaces + GarageCars + GarageArea +
           GarageQual + GarageCond + WoodDeckSF + OpenPorchSF + EnclosedPorch +
           `3SsnPorch` + ScreenPorch + PoolArea + PoolQC + SaleType +
           SaleCondition
```

\newpage

### Stepwise Selection

\label{appendix:stepWSelection}

```r
log(SalePrice) ~ 
           MSZoning + LotArea + Street + LotConfig + LandSlope +
           Neighborhood + Condition1 + Condition2 + BldgType + OverallQual +
           OverallCond + YearBuilt + YearRemodAdd + RoofStyle + RoofMatl +
           Exterior1st + MasVnrType + ExterCond + Foundation + BsmtQual +
           BsmtCond + BsmtExposure + BsmtFinSF1 + BsmtFinSF2 + BsmtUnfSF +
           Heating + HeatingQC + CentralAir + `1stFlrSF` + `2ndFlrSF` +
           LowQualFinSF + BsmtFullBath + FullBath + HalfBath + KitchenAbvGr +
           KitchenQual + Functional + Fireplaces + GarageCars + GarageArea +
           GarageQual + GarageCond + WoodDeckSF + OpenPorchSF + EnclosedPorch +
           `3SsnPorch` + ScreenPorch + PoolArea + PoolQC + SaleType +
           SaleCondition
```

### Custom Model

\label{appendix:customSelection}

```r
log(SalePrice) ~ 
            BsmtUnfSF + CentralAir + HalfBath + KitchenQual + Neighborhood +
            OverallCond + OverallQual + RoofMatl + `1stFlrSF` + `2ndFlrSF` + 
            YearBuilt + MSZoning:Neighborhood + YearBuilt:Neighborhood
```

## Kaggle Score

\label{appendix:kaggle}

The following image shows the result on Kaggle for the custom model.

```{r, kaggle, echo=F, out.width='90%', fig.align='center'}
knitr::include_graphics('./Evidence for Model Score on Kaggle.PNG')
```

\newpage

## Assumption Assessment Plots for Automatic Selection Models

\label{appendix:assessmentPlots}

The following discussion applies to the assumption assessment for the three models produced by automatic selection.

Based on the residuals vs. fitted plot, there seems to be strong linearity in the custom model, along with constant variance. The standardized residuals do not appear to exhibit a discernible pattern, indicating constant variance along the regression, or homoscedasticity. However, there are three observations with unusually high residuals.

Based on the QQ plot, there is a small level of deviation on the ends of the distribution of the errors, but for the most part, the errors adhere to normality. The sample size should be sufficient to protect against this non-normality.

Based on the standardized residuals vs. leverage plot, only a few values have high leverage and are outlying. Compared to the custom model (Figure \@ref(fig:custom-assumptions)), these diagnostic plots for these models show a few more influential observations with high leverage. However, these observations cannot be excluded from the model.

```{r, forward-assumptions, echo=F, warning=F, fig.width=5, fig.height=5, fig.align='center', fig.cap='Forward Selection Assumption Assessment Plots', out.width = '45%', fig.pos="htbp", fig.show='hold'}
# create plots of residuals
basic.fit.plots(train2, model2.Forward)
# create leverage / outlier plot
ols_plot_resid_lev(model2.Forward)
```


```{r, backward-selection, echo=F, warning=F, fig.width=5, fig.height=5, fig.align='center', fig.cap='Backward Selection Assumption Assessment Plots', out.width = '45%', fig.pos="htbp", fig.show='hold'}
# create plots of residuals
basic.fit.plots(train2, model2.Backward)
# create leverage / outlier plot
ols_plot_resid_lev(model2.Backward)
```


```{r, stepwise-assimptions, echo=F, warning=F, fig.width=5, fig.height=5, fig.align='center', fig.cap='Stepwise Selection Assumption Assessment Plots', out.width = '45%', fig.pos="htbp", fig.show='hold'}
# create plots of residuals
basic.fit.plots(train2, model2.Stepwise)
# create leverage / outlier plot
ols_plot_resid_lev(model2.Stepwise)
```

\newpage

## R Code For Analysis 1

```r
### Compuational Setup
# libraries
library(knitr)
library(kableExtra)
library(tidyverse)
library(olsrr)
library(gridExtra)
library(caret)
library(multcomp)

# load data
train <- read_csv('./data/train.csv')
test <- read_csv('./data/test.csv')

# set a random seed for repodicibility
set.seed(123)

### Helper Code

#' Print Typical Regression Fit Plots
#' 
#' @description
#' Plots QQ plot of residuals, histogram of residuals,
#' residuals vs predicted values, and studentized 
#' residuals vs predicted values. Depends on tidyverse
#' and gridExtra packages being loaded.
#'
#' @param data The true values corresponding to the input.
#' @param model The predicted/fitted values of the model.
basic.fit.plots <- function(data, model) {
	
	# depends on
	require(tidyverse)
	require(gridExtra)

	# get predicted values
	data$Predicted <- predict(model, data)
	# get residuals
	data$Resid <- model$residuals
	# get studentized residuals
	data$RStudent <- rstudent(model = model)

	# create qqplot of residuals with reference line
	qqplot.resid <- data %>% 
	  ggplot(aes(sample = Resid)) +
	  geom_qq() + geom_qq_line() +
	  labs(subtitle = 'QQ Plot of Residuals',
	       x = 'Theoretical Quantile',
	       y = 'Acutal Quantile')
	
	# create histogram of residuals
	hist.resid <- data %>% 
	  ggplot(aes(x = Resid)) +
	  geom_histogram(bins = 15) + 
	  labs(subtitle = 'Histogram of Residuals',
	       x = 'Residuals',
	       y = 'Count')

	# create scatter plot of residuals vs predicted values
	resid.vs.pred <- data %>% 
	  ggplot(aes(x = Predicted, y = Resid)) +
	  geom_point() +
	  geom_abline(slope = 0) + 
	  labs(subtitle = 'Residuals vs Prediction',
	       x = 'Predicted Value',
	       y = 'Residual')

	# create scatter plot of studentized 
	# residuals vs predicted values
	rStud.vs.pred <- data %>% 
	  ggplot(aes(x = Predicted, y = RStudent)) +
	  geom_point() +
	  geom_abline(slope = 0) + 
  	  geom_abline(slope = 0, intercept = -2) + 
  	  geom_abline(slope = 0, intercept = 2) + 
	  labs(subtitle = 'RStudent vs Prediction',
	       x = 'Predicted Value',
	       y = 'RStudent')
	
	# add all four plots to grid as
	# qqplot           histogram
	# resid vs pred    RStud vs pred
	grid.arrange(qqplot.resid,
		     hist.resid,
		     resid.vs.pred,
		     rStud.vs.pred, 
		     nrow = 2,
		     top = 'Fit Assessment Plots')
}

#' Creates dummy variables (columns) for given column
#'
#' @param data A dataframe.
#' @param column A categorical column in data.
#' @param reference A value in the column to use a reference.
#' @param as.onehot Set to TRUE to use onehot encoding.
#'
get.dummies <- function(data, column, reference, as.onehot = FALSE) {
  # get the levels of the factor in column
  lev <- levels(data[[column]])
  # do not remove reference for onehot encoding
  if (!as.onehot) {
    # remove the reference value
    lev <- lev[lev != reference]
  }
  # add encodings
  for (fct in lev){
    new_col <- paste(column, fct, sep = '_')
    data[new_col] <- as.numeric(data[, column] == fct)
    print(new_col)
  }
  data
}

#' Calculates PRESS from `caret` CV model
#'
#' @param model.cv Calculates press from a model 
#' produced by `caret`
#'
PRESS.cv <- function(model.cv) {
  meanN <- 0
  folds <- model.cv$control$index
  for (i in seq(1:length(folds))){
    meanN <- meanN + length(folds[[i]])
  }
  meanN <- meanN / length(folds)
  meanN * ((model.cv$results$RMSE)^2)
}

### plots of log of sale price ~ living room area

# create scatter plot for northwest ames
regplot.names <- train %>% filter(Neighborhood == 'NAmes') %>%
  ggplot(aes(x = (GrLivArea), y = log(SalePrice))) +
  geom_point(alpha = 0.3) +
  ylim(10, 13) +
  xlim(0, 3500) +
  labs(subtitle = 'Northwest Ames', 
       y = 'Log of Sale Price', x = 'Living Room Area (sq. ft.)')

# create scatter plot for edwards
regplot.ed <- train %>%
  filter(GrLivArea < 4000) %>%
  filter(Neighborhood == 'Edwards') %>%
  ggplot(aes(x = (GrLivArea), y = log(SalePrice))) +
  geom_point(alpha = 0.3) +
  ylim(10, 13) +
  xlim(0, 3500) +
  labs(subtitle = 'Edwards', 
       y = 'Log of Sale Price', x = 'Living Room Area (sq. ft.)')

# create regression plot for brookside
regplot.brk <- train %>% filter(Neighborhood == 'BrkSide') %>%
  ggplot(aes(x = (GrLivArea), y = log(SalePrice))) +
  geom_point(alpha = 0.3) +
  ylim(10, 13) +
  xlim(0, 3500) +
  labs(subtitle = 'Brook Side', 
       y = 'Log of Sale Price', x = 'Living Room Area (sq. ft.)')

# add the scatter plots for the neighborhood into a single plot
grid.arrange(regplot.names,regplot.ed,regplot.brk, nrow = 2,
             top = 'Regression Plots for Neighborhoods')

# scatter plot of observations from all three neighborhoods
train %>% 
  filter(GrLivArea < 4000) %>%
  ggplot(aes(x = (GrLivArea), y = log(SalePrice))) +
  geom_point(alpha = 0.3) +
  labs(title = 'Log of Sale Price vs Living Room Area', 
       y = 'Log of Sale Price', x = 'Living Room Area (sq. ft.)')

### Filter data for analysis 1

train <- train %>% 
  filter(Neighborhood %in% c("Edwards", "BrkSide", "NAmes"))
train$Neighborhood <- as.factor(train$Neighborhood)

# create dummy variables with Neighborhood == 'Edwards' as reference
train <- get.dummies(train, "Neighborhood", reference = 'Edwards')

# remove suspect points from training data
train.mod <- train %>% filter(GrLivArea < 4000)

#### Extra Sum of Squares

# full model formula
model.formula = log(SalePrice) ~ (GrLivArea) + 
     Neighborhood_BrkSide + 
     Neighborhood_NAmes +
     (GrLivArea) * Neighborhood_BrkSide + 
     (GrLivArea) * Neighborhood_NAmes
# reduced model formula
model.reduced.formula = log(SalePrice) ~ (GrLivArea) + 
     Neighborhood_BrkSide + 
     Neighborhood_NAmes

# fit models
model <- lm(formula = model.formula, data = train.mod)
model.reduced <- lm(formula = model.reduced.formula, data = train.mod)
# ESS test on models
anova(model.reduced, model)

### Assessment plots

# create plots of residuals
basic.fit.plots(train.mod, model)
# create leverage / outlier plot
ols_plot_resid_lev(model)

### cross validation

## cross validate the full model

# Set up repeated k-fold cross-validation
train.control <- trainControl(method = "cv", number = 10)
# Train the model
model.cv <- train(model.formula, 
                    data = train.mod,
                    method = 'lm',
                    trControl = train.control)
# print model summary
model.cv

# get the CV results
res <- model.cv$results

# get cross-validated PRESS statistic
PCV <- PRESS.cv(model.cv)

## cross validate the reduced model

# Set up repeated k-fold cross-validation
train.control <- trainControl(method = "cv", number = 10)
# Train the model
model.reduced.cv <- train(model.reduced.formula, 
                    data = train.mod,
                    method = 'lm',
                    trControl = train.control)
# print model summary
model.reduced.cv

# get the CV results
res.red <- model.reduced.cv$results

# get cross-validated PRESS statistic
PCV.red <- PRESS.cv(model.reduced.cv)

# print accuracy metrics to md table
kable(data.frame('Model' = c('Full Model', 'Reduced Model'), 
                 'RMSE'=c(res$RMSE, res.red$RMSE),
                 'CV Press'=c(PCV, PCV.red),
                 'Adjused R Squared'=c(res$Rsquared, res.red$Rsquared)),
      "latex", booktabs = T)  %>%
  kable_styling(position = "center")

### get the parameters from the CV'ed model

# extract the model estimates from the model summary
sm <- summary(model)
sm.coe <- sm$coefficients
# get the CIs for the coefficients
model.conf <- confint(model)

# print model estimates to md / latex table
# extract the params and put into a dataframe
kable(data.frame('Parameter' = c('Intercept', 'GrLivArea', 
                                 'Neighborhood_BrkSide', 'Neighborhood_NAmes', 
                                 'GrLivArea:Neighborhood_BrkSide', 
                                 'GrLivArea:Neighborhood_NAmes '), 
                 'Estimate'=c(sm.coe[[1]],sm.coe[[2]],sm.coe[[3]],
                              sm.coe[[4]],sm.coe[[5]],sm.coe[[6]]),
                 'CI Lower' = c(model.conf[[1]],model.conf[[2]],model.conf[[3]],
                                model.conf[[4]],model.conf[[5]],model.conf[[6]]),
                 'CI Upper' = c(model.conf[[1,2]],model.conf[[1,2]],model.conf[[3,2]],
                                model.conf[[4,2]],model.conf[[5,2]],model.conf[[6,2]])),
      "latex", booktabs = T)  %>%
  kable_styling(position = "center")

# summary of model to get overall test
summary(lm(model.formula, data = train.mod))

## Calculate CIs of slopes not in standard table

# get CI for Northwest Ames
confint(glht(model, linfct = "GrLivArea + GrLivArea:Neighborhood_NAmes = 1"))

# get CI for Brookside
confint(glht(model, linfct = "GrLivArea + GrLivArea:Neighborhood_BrkSide = 1"))

```

\newpage

## R Code For Analysis 2

```r
# libraries
library(knitr)
library(tidyverse)
library(naniar)
library(Hmisc)
library(GGally)
library(corrr)
library(MASS)
library(caret)


# helper files
# source('../../helper/data_munging.R')


#' Calculates PRESS from `caret` CV model
#'
#' @param model.cv Calculates press from a model 
#' produced by `caret`
#'
PRESS.cv <- function(model.cv) {
  meanN <- 0
  folds <- model.cv$control$index
  for (i in seq(1:length(folds))){
    meanN <- meanN + length(folds[[i]])
  }
  meanN <- meanN / length(folds)
  meanN * ((model.cv$results$RMSE)^2)
}

## Load the data into R

train <- read_csv('../../data/train.csv')
test <- read_csv('../../data/test.csv')


## Data Cleaning

###  Handle null values for continuous variables

# Garage Year Built {"train": 81, "test": 78}
train$GarageYrBlt[is.na(train$GarageYrBlt)] <- 0
test$GarageYrBlt[is.na(test$GarageYrBlt)] <- 0

# Lot Frontage {"train": 259, "test": 227}
train$LotFrontage[is.na(train$LotFrontage)] <- mean(train$LotFrontage, na.rm=TRUE)
test$LotFrontage[is.na(test$LotFrontage)] <- mean(test$LotFrontage, na.rm=TRUE)

# MasVnrArea {"train": 8, "test": 15}
train$MasVnrArea[is.na(train$MasVnrArea)] <- 0
test$MasVnrArea[is.na(test$MasVnrArea)] <- 0


###  Handle null values for categorical variables

train$Alley[is.na(train$Alley)] <- 'None'
test$Alley[is.na(test$Alley)] <- 'None'

train$MasVnrType[is.na(train$MasVnrType)] <- 'None'
test$MasVnrType[is.na(test$MasVnrType)] <- 'None'

train$BsmtQual[is.na(train$BsmtQual)] <- 'None'
test$BsmtQual[is.na(test$BsmtQual)] <- 'None'

train$BsmtCond[is.na(train$BsmtCond)] <- 'None'
test$BsmtCond[is.na(test$BsmtCond)] <- 'None'

train$BsmtExposure[is.na(train$BsmtExposure)] <- 'None'
test$BsmtExposure[is.na(test$BsmtExposure)] <- 'None'

train$BsmtFinType1[is.na(train$BsmtFinType1)] <- 'None'
test$BsmtFinType1[is.na(test$BsmtFinType1)] <- 'None'

train$BsmtFinType2[is.na(train$BsmtFinType2)] <- 'None'
test$BsmtFinType2[is.na(test$BsmtFinType2)] <- 'None'

train$FireplaceQu[is.na(train$FireplaceQu)] <- 'None'
test$FireplaceQu[is.na(test$FireplaceQu)] <- 'None'

train$GarageType[is.na(train$GarageType)] <- 'None'
test$GarageType[is.na(test$GarageType)] <- 'None'

train$GarageFinish[is.na(train$GarageFinish)] <- 'None'
test$GarageFinish[is.na(test$GarageFinish)] <- 'None'

train$GarageQual[is.na(train$GarageQual)] <- 'None'
test$GarageQual[is.na(test$GarageQual)] <- 'None'

train$GarageCond[is.na(train$GarageCond)] <- 'None'
test$GarageCond[is.na(test$GarageCond)] <- 'None'

train$PoolQC[is.na(train$PoolQC)] <- 'None'
test$PoolQC[is.na(test$PoolQC)] <- 'None'

train$Fence[is.na(train$Fence)] <- 'None'
test$Fence[is.na(test$Fence)] <- 'None'

train$MiscFeature[is.na(train$MiscFeature)] <- 'None'
test$MiscFeature[is.na(test$MiscFeature)] <- 'None'

train$Electrical[is.na(train$Electrical)] <- 'SBrkr'
test$Electrical[is.na(test$Electrical)] <- 'SBrkr'

train$BldgType[is.na(train$BldgType)] <- '1Fam'
test$BldgType[is.na(test$BldgType)] <- '1Fam'

train$BsmtExposure[is.na(train$BsmtExposure)] <- 'None'
test$BsmtExposure[is.na(test$BsmtExposure)] <- 'None'

train$Neighborhood <- as.factor(train$Neighborhood)
test$Neighborhood <- as.factor(test$Neighborhood)

train$BldgType <- as.factor(train$BldgType)
test$BldgType <- as.factor(test$BldgType)

train$HouseStyle <- as.factor(train$HouseStyle)
test$HouseStyle <- as.factor(test$HouseStyle)

train$RoofStyle <- as.factor(train$RoofStyle)
test$RoofStyle <- as.factor(test$RoofStyle)

train$RoofMatl <- as.factor(train$RoofMatl)
test$RoofMatl <- as.factor(test$RoofMatl)

train$Exterior1st <- as.factor(train$Exterior1st)
test$Exterior1st <- as.factor(test$Exterior1st)

train$Exterior2nd <- as.factor(train$Exterior2nd)
test$Exterior2nd <- as.factor(test$Exterior2nd)

train$ExterQual <- as.factor(train$ExterQual)
test$ExterQual <- as.factor(test$ExterQual)

train$ExterCond <- as.factor(train$ExterCond)
test$ExterCond <- as.factor(test$ExterCond)

train$Foundation <- as.factor(train$Foundation)
test$Foundation <- as.factor(test$Foundation)

train$Heating <- as.factor(train$Heating)
test$Heating <- as.factor(test$Heating)

train$HeatingQC <- as.factor(train$HeatingQC)
test$HeatingQC <- as.factor(test$HeatingQC)

train$CentralAir <- as.factor(train$CentralAir)
test$CentralAir <- as.factor(test$CentralAir)

train$KitchenQual <- as.factor(train$KitchenQual)
test$KitchenQual <- as.factor(test$KitchenQual)

train$Functional <- as.factor(train$Functional)
test$Functional <- as.factor(test$Functional)

train$PavedDrive <- as.factor(train$PavedDrive)
test$PavedDrive <- as.factor(test$PavedDrive)

train$SaleType <- as.factor(train$SaleType)
test$SaleType <- as.factor(test$SaleType)

train$Utilities <- as.factor(train$Utilities)
test$Utilities <- as.factor(test$Utilities)


### set ordinal factors


# 1)  Remove Basement Condition as it is highly correlated to Basement Quality
# 2)  Remove Garage Condition as it is highly correlated to Garage Quality
# 3)  Remove utilities from dataframe as it doesn't have enough observations
#     in the 2 levels
train = subset(train, select = -c(Utilities, BsmtCond, GarageCond) )
test = subset(test, select = -c(Utilities, BsmtCond, GarageCond) )



################################################################

# MS ordinal factors

train$MSSubClass <- dplyr::recode(train$MSSubClass, `30` = "30F", `180` = "180F",
                                  `45` = "45F", `190` = "190F",
                                  `90` = "190F", `160` = "160F", `50` = "50F",
                                  `40` = "40F", `85` = "85F", `70` = "70F",
                                 `80` = "80F", `20` = "20F", `75` = "75F",
                                 `120` = "120F", `60` = "60F", `150` = "75F")

test$MSSubClass <- dplyr::recode(test$MSSubClass, `30` = "30F", `180` = "180F",
                                 `45` = "45F", `190` = "190F",
                                  `90` = "190F", `160` = "160F", `50` = "50F",
                                  `40` = "40F", `85` = "85F", `70` = "70F",
                                 `80` = "80F", `20` = "20F", `75` = "75F",
                                 `120` = "120F", `60` = "60F", `150` = "75F")


train$MSSubClass <- as.factor(train$MSSubClass)
test$MSSubClass <- as.factor(test$MSSubClass)

train$MSZoning <- dplyr::recode(train$MSZoning, 'C (all)' = 0,
                                'RM' = 1, 'RH' = 2, 'RL' = 3, 'FV' = 4)
test$MSZoning <- dplyr::recode(test$MSZoning, 'C (all)' = 0,
                               'RM' = 1, 'RH' = 2, 'RL' = 3, 'FV' = 4)

################################################################

# garage ordinal factors

train$GarageQual <- dplyr::recode(train$GarageQual, 'None' = 0, 'Po' = 1,
                                  'Fa' = 2, 'TA' = 3, 'Gd' = 4, 'Ex' = 5)
test$GarageQual <- dplyr::recode(test$GarageQual, 'None' = 0, 'Po' = 1,
                                 'Fa' = 2, 'TA' = 3, 'Gd' = 4, 'Ex' = 5)

train$GarageFinish <- dplyr::recode(train$GarageFinish, 'None' = 0, 'Unf' = 1,
                                    'RFn' = 2, 'Fin' = 3)
test$GarageFinish <- dplyr::recode(test$GarageFinish, 'None' = 0, 'Unf' = 1,
                                   'RFn' = 2, 'Fin' = 3)

train$GarageType <- dplyr::recode(train$GarageType, 'None' = 0, 'CarPort' = 1,
                                  '2Types' = 2, 'Basment' = 3, 
                                  'Detchd' = 4, 'Attchd' = 5, 'BuiltIn' = 6)

test$GarageType <- dplyr::recode(test$GarageType, 'None' = 0, 'CarPort' = 1,
                                  '2Types' = 2, 'Basment' = 3, 
                                  'Detchd' = 4, 'Attchd' = 5, 'BuiltIn' = 6)


# train$GarageCond <- dplyr::recode(train$GarageCond, 'None' = 0, 'Po' = 1,
                                    'Fa' = 2, 'TA' = 3, 'Gd' = 4, 'Ex' = 5)
# test$GarageCond <- dplyr::recode(test$GarageCond, 'None' = 0, 'Po' = 1, 'Fa' = 2,
                                   'TA' = 3, 'Gd' = 4, 'Ex' = 5)

################################################################

# basement ordinal factors

train$BsmtQual <- dplyr::recode(train$BsmtQual, 'None' = 0, 'Po' = 1,
                                'Fa' = 2, 'TA' = 3, 'Gd' = 4, 'Ex' = 5)
test$BsmtQual <- dplyr::recode(test$BsmtQual, 'None' = 0, 'Po' = 1,
                               'Fa' = 2, 'TA' = 3, 'Gd' = 4, 'Ex' = 5)

# train$BsmtCond <- dplyr::recode(train$BsmtCond, 'None' = 0, 'Po' = 1,
                                  'Fa' = 2, 'TA' = 3, 'Gd' = 4, 'Ex' = 5)
# test$BsmtCond <- dplyr::recode(test$BsmtCond, 'None' = 0, 'Po' = 1,
                                 'Fa' = 2, 'TA' = 3, 'Gd' = 4, 'Ex' = 5)


train$BsmtFinType1 <- dplyr::recode(train$BsmtFinType1, 'None' = 0,
                                    'Unf' = 1, 'LwQ' = 2, 'Rec' = 3, 
                                    'BLQ' = 4, 'ALQ' = 5, 'GLQ' = 6)

test$BsmtFinType1 <- dplyr::recode(test$BsmtFinType1, 'None' = 0,
                                   'Unf' = 1, 'LwQ' = 2, 'Rec' = 3, 
                                   'BLQ' = 4, 'ALQ' = 5, 'GLQ' = 6)


train$BsmtFinType2 <- dplyr::recode(train$BsmtFinType2, 'None' = 0,
                                    'Unf' = 1, 'LwQ' = 2, 'Rec' = 3, 
                                    'BLQ' = 4, 'ALQ' = 5, 'GLQ' = 6)
test$BsmtFinType2 <- dplyr::recode(test$BsmtFinType2, 'None' = 0,
                                   'Unf' = 1, 'LwQ' = 2, 'Rec' = 3, 
                                   'BLQ' = 4, 'ALQ' = 5, 'GLQ' = 6)


train$BsmtExposure <- dplyr::recode(train$BsmtExposure, 'None' = 0,
                                    'No' = 1, 'Mn' = 2, 'Av' = 3, 'Gd' = 4)
test$BsmtExposure <- dplyr::recode(test$BsmtExposure, 'None' = 0, 'No' = 1,
                                   'Mn' = 2, 'Av' = 3, 'Gd' = 4)

################################################################

# ordinal factors for misc features

train$LandSlope <- dplyr::recode(train$LandSlope, 'Sev' = 0, 'Mod' = 1,
                                 'Gtl' = 2)
test$LandSlope <- dplyr::recode(test$LandSlope, 'Sev' = 0, 'Mod' = 1,
                                'Gtl' = 2)

train$PoolQC <- dplyr::recode(train$PoolQC, 'None' = 0, 'Po' = 1,
                              'Fa' = 2, 'TA' = 3, 'Gd' = 4, 'Ex' = 5)
test$PoolQC <- dplyr::recode(test$PoolQC, 'None' = 0, 'Po' = 1,
                             'Fa' = 2, 'TA' = 3, 'Gd' = 4, 'Ex' = 5)


train$FireplaceQu <- dplyr::recode(train$FireplaceQu, 'None' = 0,
                                   'Po' = 1, 'Fa' = 2, 'TA' = 3, 'Gd' = 4,
                                   'Ex' = 5)
test$FireplaceQu <- dplyr::recode(test$FireplaceQu, 'None' = 0,
                                  'Po' = 1, 'Fa' = 2, 'TA' = 3, 'Gd' = 4,
                                  'Ex' = 5)

################################################################



### Set categorical factor variables


train$Street <- ordered(train$Street, levels = c("Grvl", "Pave"))
test$Street <- ordered(test$Street, levels = c("Grvl", "Pave"))

train$LotShape <- ordered(train$LotShape, levels = c("Reg", "IR1",
                          "IR2", "IR3"))
test$LotShape <- ordered(test$LotShape, levels = c("Reg", "IR1",
                         "IR2", "IR3"))

train$LandContour <- ordered(train$LandContour,
                             levels = c("Bnk", "Lvl", "Low", "HLS"))
test$LandContour <- ordered(test$LandContour,
                            levels = c("Bnk", "Lvl", "Low", "HLS"))

train$LotConfig <- ordered(train$LotConfig,
                           levels = c("Inside", "Corner", "CulDSac",
                           "FR2", "FR3"))
test$LotConfig <- ordered(test$LotConfig,
                          levels = c("Inside", "Corner", "CulDSac",
                          "FR2", "FR3"))

train$Condition1 <- ordered(train$Condition1,
                            levels = c("Artery", "Feedr", "RRAe",
                            "Norm", "RRAn", "RRNe", "RRNn", "PosA",
                            "PosN"))
test$Condition1 <- ordered(test$Condition1,
                           levels = c("Artery", "Feedr", "RRAe",
                           "Norm", "RRAn", "RRNe", "RRNn", "PosA",
                           "PosN"))

train$Condition2 <- ordered(train$Condition2,
                            levels = c("Artery", "RRNn","RRAn",
                            "Feedr", "Norm", "RRAe", "PosN", "PosA"))
test$Condition2 <- ordered(test$Condition2,
                           levels = c("Artery", "RRNn","RRAn",
                           "Feedr", "Norm", "RRAe", "PosN", "PosA"))

train$Alley <- ordered(train$Alley, levels = c("None", "Grvl", "Pave"))
test$Alley <- ordered(test$Alley, levels = c("None", "Grvl", "Pave"))

train$MasVnrType <- ordered(train$MasVnrType,
                            levels = c("None", "CBlock", "BrkFace",
                            "BrkCmn", "Stone"))
test$MasVnrType <- ordered(test$MasVnrType,
                           levels = c("None", "CBlock", "BrkFace",
                           "BrkCmn", "Stone"))

train$Fence <- ordered(train$Fence,
                       levels = c("None", "MnWw", "GdWo",
                       "MnPrv", "GdPrv"))
test$Fence <- ordered(test$Fence,
                       levels = c("None", "MnWw", "GdWo",
                       "MnPrv", "GdPrv"))

train$Electrical <- ordered(train$Electrical,
                            levels = c("Mix", "FuseP",
                            "FuseF", "FuseA", "SBrkr"))
test$Electrical <- ordered(test$Electrical,
                           levels = c("Mix", "FuseP",
                           "FuseF", "FuseA", "SBrkr"))

train$MiscFeature <- ordered(train$MiscFeature,
                             levels = c("None", "Othr",
                             "Shed", "Gar2", "TenC"))
test$MiscFeature <- ordered(test$MiscFeature,
                            levels = c("None", "Othr",
                            "Shed", "Gar2", "TenC"))

train$SaleCondition <- factor(train$SaleCondition,
                              levels = c("Abnorml", "AdjLand",
                              "Alloca", "Partial", "Family", "Normal"))
test$SaleCondition <- factor(test$SaleCondition,
                             levels = c("Abnorml", "AdjLand",
                             "Alloca", "Partial", "Family", "Normal"))

### Model Definitions

### custom model ###
custom.model.formula <- log(SalePrice) ~ MSSubClass + MSZoning + LotFrontage + 
    LotArea + Street + Neighborhood + 
    Condition1 + OverallQual + OverallCond + YearBuilt + YearRemodAdd + 
    ExterCond + Foundation + 
    BsmtExposure + BsmtFinType1 + BsmtFinSF1 + BsmtFinSF2 + BsmtUnfSF + 
    HeatingQC + CentralAir + Electrical + `1stFlrSF` + 
    `2ndFlrSF` + LowQualFinSF + BsmtFullBath + FullBath + HalfBath + 
    KitchenAbvGr + KitchenQual + Functional + FireplaceQu + GarageYrBlt + 
    GarageCars + GarageArea + GarageQual + WoodDeckSF + OpenPorchSF + 
    EnclosedPorch + ScreenPorch + SaleType + SaleCondition


### forward model ###
fwd.model.formula <- log(SalePrice) ~ OverallQual + GrLivArea + Neighborhood + 
    BsmtFinSF1 + MSSubClass + OverallCond + YearBuilt + GarageCars + 
    TotalBsmtSF + SaleCondition + LotArea + MSZoning + Functional + 
    CentralAir + KitchenQual + Condition1 + FireplaceQu + BsmtExposure + 
    BsmtFullBath + ScreenPorch + Exterior1st + YearRemodAdd + 
    GarageQual + WoodDeckSF + OpenPorchSF + Street + LotConfig + 
    LotFrontage + Foundation + Heating + KitchenAbvGr + EnclosedPorch + 
    HalfBath + FullBath + MasVnrType + BsmtFinSF2 + HeatingQC + 
    GarageArea + SaleType + ExterCond + PoolArea + BsmtFinType1 + 
    GarageYrBlt + Electrical + `3SsnPorch` + LowQualFinSF


### backward model ###
bkw.model.formula <- log(SalePrice) ~ MSSubClass + MSZoning + LotFrontage +
    LotArea + Street + LotConfig + LandSlope + Neighborhood +
    Condition1 + OverallQual + OverallCond + YearBuilt + YearRemodAdd +
    RoofMatl + Exterior1st + MasVnrType + ExterCond + Foundation +
    BsmtExposure + BsmtFinType1 + BsmtFinSF1 + BsmtFinSF2 + BsmtUnfSF +
    Heating + HeatingQC + CentralAir + Electrical + `1stFlrSF` +
    `2ndFlrSF` + LowQualFinSF + BsmtFullBath + FullBath + HalfBath +
    KitchenAbvGr + KitchenQual + Functional + FireplaceQu + GarageYrBlt +
    GarageCars + GarageArea + GarageQual + WoodDeckSF + OpenPorchSF +
    EnclosedPorch + ScreenPorch + PoolArea + SaleType + SaleCondition


### stepwise model ###
stw.model.formula <- log(SalePrice) ~ OverallQual + GrLivArea + Neighborhood + 
    BsmtFinSF1 + MSSubClass + OverallCond + YearBuilt + GarageCars + 
    TotalBsmtSF + SaleCondition + LotArea + MSZoning + Functional + 
    CentralAir + KitchenQual + Condition1 + FireplaceQu + BsmtExposure + 
    BsmtFullBath + ScreenPorch + Exterior1st + YearRemodAdd + 
    GarageQual + WoodDeckSF + OpenPorchSF + Street + LotConfig + 
    LotFrontage + Foundation + Heating + KitchenAbvGr + EnclosedPorch + 
    HalfBath + FullBath + MasVnrType + BsmtFinSF2 + HeatingQC + 
    GarageArea + SaleType + ExterCond + PoolArea + BsmtFinType1 + 
    GarageYrBlt + Electrical + `3SsnPorch` + LowQualFinSF


custom.model <- lm(custom.model.formula,
               data = train)


fwd.model <- lm(fwd.model.formula,
               data = train)

bkw.model <- lm(bkw.model.formula,
               data = train)

stw.model <- lm(stw.model.formula,
               data = train)


# Fit the model with all parameters
fit1 <- lm(log(SalePrice) ~ ., data=train)

# Fit the model with only 1 parameter
fit2 <- lm(log(SalePrice) ~ 1, data=train)


### Custom Model

test$predicted.log.price <- predict.lm(custom.model, test)
test$predicted.log.price[is.na(test$predicted.log.price)] <-
  mean(test$predicted.log.price, na.rm=TRUE)
  
custom_submit <- test %>%
  mutate(SalePrice = exp(predicted.log.price)) %>%
  subset(select = c(Id, SalePrice))

# write.csv(custom_submit, 
#  file = "./cwr_kaggle_submission_custom_model.csv",
#  row.names = FALSE)

summary(custom.model)


### Forward Model

test$predicted.log.price <- predict.lm(fwd.model, test)
test$predicted.log.price[is.na(test$predicted.log.price)] <- 
  mean(test$predicted.log.price, na.rm=TRUE)
  
forward_submit <- test %>%
  mutate(SalePrice = exp(predicted.log.price)) %>%
  subset(select = c(Id, SalePrice))

# write.csv(forward_submit, 
#  file = "./cwr_kaggle_submission_forward_model.csv", 
#  row.names = FALSE)

summary(fwd.model)


### Backward Model

test$predicted.log.price <- predict.lm(bkw.model, test)
test$predicted.log.price[is.na(test$predicted.log.price)] <- 
  mean(test$predicted.log.price, na.rm=TRUE)
  
backward_submit <- test %>%
  mutate(SalePrice = exp(predicted.log.price)) %>%
  subset(select = c(Id, SalePrice))

# write.csv(backward_submit,
#  file = "./cwr_kaggle_submission_backward_model.csv",
#  row.names = FALSE)

summary(bkw.model)


### Stepwise Model

test$predicted.log.price <- predict.lm(stw.model, test)
test$predicted.log.price[is.na(test$predicted.log.price)] <- 
  mean(test$predicted.log.price, na.rm=TRUE)
  
stepwise_submit <- test %>%
  mutate(SalePrice = exp(predicted.log.price)) %>%
  subset(select = c(Id, SalePrice))

# write.csv(stepwise_submit,
#  file = "./cwr_kaggle_submission_stepwise_model.csv",
#  row.names = FALSE)

summary(stw.model)


## Cross Validation

### Custom Model CV

# Set up repeated k-fold cross-validation
train.control <- trainControl(method = "cv", number = 10)

# Train the model
custom.model.cv <- train(custom.model.formula, 
                    data = train,
                    method = 'lm',
                    trControl = train.control)

custom.model.cv


# get cross-validated PRESS statistic
PCV <- PRESS.cv(custom.model.cv)
PCV


### Forward Model CV

# Set up repeated k-fold cross-validation
train.control <- trainControl(method = "cv", number = 10)

# Train the model
fwd.model.cv <- train(fwd.model.formula, 
                    data = train,
                    method = 'lm',
                    trControl = train.control)

fwd.model.cv


# get cross-validated PRESS statistic
PCV <- PRESS.cv(fwd.model.cv)
PCV


### Backward Model CV

# Set up repeated k-fold cross-validation
train.control <- trainControl(method = "cv", number = 10)

# Train the model
bkw.model.cv <- train(bkw.model.formula, 
                    data = train,
                    method = 'lm',
                    trControl = train.control)

bkw.model.cv

# get cross-validated PRESS statistic
PCV <- PRESS.cv(bkw.model.cv)
PCV

### Stepwise Model CV

# Set up repeated k-fold cross-validation
train.control <- trainControl(method = "cv", number = 10)

# Train the model
stw.model.cv <- train(stw.model.formula, 
                    data = train,
                    method = 'lm',
                    trControl = train.control)

stw.model.cv


# get cross-validated PRESS statistic
PCV <- PRESS.cv(stw.model.cv)
PCV

### AIC functions for different model types

bwd.model <- stepAIC(fit1,direction="backward")

fwd.model <- stepAIC(fit2,direction="forward",scope=list(upper=fit1,lower=fit2))

stw.model <- stepAIC(fit2,direction="both",scope=list(upper=fit1,lower=fit2))

summary(bwd.model)
summary(fwd.model)
summary(stw.model)
```

\newpage

# References
